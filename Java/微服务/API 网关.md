#### API 网关

##### 1.为什么需要API网关

举个比较生动的例子,一个大型的演奏乐队中,总是需要一个指挥家.乐手负责演奏自己的乐器,而这个指挥家(API网关)可以以某种方式来协调我们的架构是如何处理请求.

##### 2. API网关模式(API Gateway Pattern)

API网关其实跟设计模式中的Facade模式以及代理模式相似.

为什么与Facade模式相似?

举个非常简单易懂的例子:一个电源总开关可以控制四盏灯,一个风扇,一台空调和一台电视机的启动和关闭.该电源总开关可以同时控制上述所有电器设备,电源总开关即为这个系统的外观模式设计.

从以上的例子可以看出很大程度上降低了复杂性,Facade模式定义了一个高层接口,这个接口使得子系统更加容易引用.客户端只需要与接口交互,客户端与子系统的复杂性由该接口的实现类来实现,进而降低了系统的耦合度.

![](http://my.csdn.net/uploads/201205/04/1336117360_9418.jpg)

API网关模式意味着我们需要把API网关放到微服务的最前端,并且要让API网关变成由应用发起每个请求的入口.

##### 3. 优化后的端点

同样地举个例子来说明一下

![](http://blog.didispace.com/content/images/posts/hzf-ms-apigateway-1-11.png)

假设现在有三个模块:订单,用户,发票每个模块都需要返回不同的JSON响应,而且客户端也需要查看这些返回的响应.现在有两个方法来解决:

第一种方式:客户端按顺序的向客户,订单,发票模块发送请求.

第二种方式:使用API网关来抽象客户端实现的复杂性,由API网关公开一个特定的端点,然后在这个端点上产生请求,最后在消费完微服务之后返回给客户端一个唯一的响应.

而且使用第二种方式的话API网关让客户端不需要关心模块的地址了,网关负责来搞这些事情,我们只需要知道网关就可以了,可以去改变实现而且还可以改变API接口.重点是,把很多的Response变成了一个,而Request也是一个.

##### 4. 中心化中间件

![](http://blog.didispace.com/content/images/posts/hzf-ms-apigateway-1-12.png)

有的服务是public的；有的是private的；有的则是合作伙伴的API，这些你只能提供给一些特定的用户。迟早你会发现自己在实现每个微服务时总是一次次的重复编写一些相同的代码，这些代码其实都是可以抽象为中间件的。

这显然不是每个微服务应该去关注的事情。API网关才应该把这件事情揽下，也就是说微服务只负责接收进来的request-然后返回一个类似JSON格式的response即可。然后API网关就把这些例如身份验证、日志（logging）以及流量控制都归于麾下.

##### 5. 流量控制

![](http://blog.didispace.com/content/images/posts/hzf-ms-apigateway-1-14.png)

当需要发行新版本的时候,有时候我们并不希望让所有的流量都一次性的到达新的版本,原因是新的版本可能还没有进行充分的测试.而这个金丝雀的策略可以允许导入指定的流量到新的版本,API网关就可以来完成这件事情.可以配置10%的请求到新的版本,一旦确认了没有BUG,就可以把流量切换到100%.

##### 6. 负载均衡(Load Banlancign)

![](http://blog.didispace.com/content/images/posts/hzf-ms-apigateway-1-15.png)

API网关的另外的一个能力就是可以负载均衡。在一定场景下，API网关可以是负载均衡器。API网关知道所有的service的地址和位置，所以你可以在API网关和上游service之间加一个负载均衡器。或者它本身就是一个负载均衡器。

##### 7. 断路器(Circuit Breaker)



![](http://blog.didispace.com/content/images/posts/hzf-ms-apigateway-1-16.png)

API网关可以帮你实现断路器(circuit breakers)的能力,也就是说超过了指定的阈值，API网关就会停止发送数据到那些失败的模块。

这样就给了我们时间来分析日志，实现修复以及push更新。通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。