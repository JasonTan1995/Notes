### Eureka

​    Spring Cloud Eureka,开发人员可以通过Netflix Eureka来实现服务注册与发现,它既包括了服务端组件也包括了客户端组件.

​    Eureka的服务端一般用来做服务的注册中心,该注册中心与大多数的注册中心一样,支持高可用的配置.那么高可用怎么体现?如果Eureka以集群模式部署,当集群中的某一节点出现故障了,那么Eureka就会进入自我保护模式,故障期间会继续提供服务注册与发现,当出现故障的节点重新恢复的时候,集群中的其他节点会把出现故障的节点的状态同步回来.

​    Eureka的客户端,主要处理服务的注册与发现.客户端服务可以通过注解和参数配置的方式,嵌入到客户端应用程序的代码中.并且会周期性发送心跳到注册中心中来更新它的服务.

### Eureka详解

##### Eureka服务治理体系中有三个核心角色:服务注册中心,服务提供者以及服务消费者.

1. 服务注册中心:Eureka提供的服务端,提供服务注册与发现的功能.
2. 服务提供者:提供服务的应用,该应用只要遵循Eureka通信机制即能将自己的服务注册到Eureka,以供给其他应用发现使用.
3. 服务消费者:消费者应用从服务注册中心获取服务列表.从而让消费者可以知道去哪里调用它所需要的服务.

**很多时候,客户端既是服务提供者也是服务消费者.**

#####     服务治理机制

​         下面的结构是基础的eureka结构,从该结构图中已经能体现出eureka的高可用特性.

![](https://ws1.sinaimg.cn/large/6b297ce5gy1fxx1pljdvbj20km0dd78d.jpg)

​      接下来根据结构图来说说这些结构元素中的一些通信行为.

- 服务注册中心-1 和 服务注册中心-2 互相注册组成了高可用集群.

- 服务提供者启动两个实例分别向两个注册中心注册服务.

- 两个服务消费者指向了两个注册中心.



  ##### 服务提供者

​       **(服务注册)**服务提供者在启动的时候会通过发送REST请求的方式注册到Eureka Server中并同时带上了自身服务的一些元数据信息.Eureka Server接受到这个REST请求之后,会将这些元信息存储在一个双层结构Map中,第一层的key是服务名,第二层的key是具体服务的实例名.

![](https://ws1.sinaimg.cn/large/6b297ce5gy1fxx3ad9uk6j211f04e751.jpg)

​      另外需要注意的是,在服务注册时,需要确认**eureka.client.register-with-eureka=true**参数是否正确,该值默认为true.如果设置了false将不会启动注册操作.

##### (服务同步)那么这个时候我们需要思考一个问题,如果其中一个服务注册中心宕机了,某个服务提供者向该宕机了的注册中心注册会发生什么情况?

​       Dubbo中使用的Zookeeper集群会有主从模式,主机如果宕机了,每个Slaver通过类似心跳机制会检测到主机宕机,然后就会进行从新选举出新的主机.以继续提供服务的注册与发现.待原来的主机恢复后,再与原来的主机进行同步数据.

​       那么其实在Eureka中也是差不多的,如图中所示,两个服务提供者分别注册到两个不同的服务注册中心上,它们的信息分别被两个服务注册中心所维护.由于两个服务注册中心之间是互相注册服务.当其中一个服务提供者发送注册请求到一个服务注册中心时,它会将该请求转发给集群中相连的其他注册中心.从而实现注册中心之间的服务同步.

**(服务续约)**在注册服务之后,服务提供者会维护一个心跳来持续告诉Eureka Server还在,以防止Eureka Server的将该服务实例从该服务列表中排除出去.这个操作就称之为服务续约(Renew)

关于服务续约有两个比较重要的属性:

```
//定义服务续约任务的调用时间(默认30秒)
eureka.instance.lease-renewal-interval-in-seconds=30
//定义服务失效时间(默认90秒)
eureka.instance.lease-expiration-duration-in-seconds=90
```

      #####     服务消费者

​          **(获取服务)**服务注册中心注册了一个服务,当我们启动消费者的时候,它会发送一个REST请求给服务注册中心.来获取上面注册的服务清单.出于性能的考虑,Eureka Server会维护一份只读的服务清单来返回给客户端,同时会缓存这份清单,每隔30秒刷新一次.

```
//该配置用于获取服务(默认值为true)
eureka.client.fetch-registry=true
//缓存清单的更新时间(默认值为30秒,单位为秒)
eureka.client.registry-fetch-interval-seconds=30
```

​         **(服务调用)**服务消费者在获取服务清单后,通过服务名可以获得具体提供服务的实例名和该实例的元数据信息.正是因为有这些服务实例的详细信息,所以客户端才能根据自己的需要决定具体调用哪个实例.(在Ribbon中会默认采用轮询的方式进行调用,从而实现客户端的负载均衡)

​         **(服务下线)**在系统运行过程中肯定会发生面临关闭或重启服务的某个实例,因此我们并不希望客户端继续调用关闭了的实例.所以在客户端程序中,服务实例进行关闭时会触发一个服务下线的REST请求给Eureka Server告诉服务注册中心要下线了.服务端在接收到请求之后,将该服务状态设置为DOWN.并把下线时间传播出去.

##### 服务注册中心

​        **(失效剔除)**服务实例可能有些时候会由于内存溢出,网络故障等原因使得服务不能正常工作.但又没有发送请求到服务注册中心通知服务下线.Eureka Server在启动的时候创建了一个定时任务.默认每隔一段时间(默认60秒)将当前清单中超时(默认为90秒)没有续约的服务剔除出清单中.

​       **(自我保护)**以下的这种情况多出于本地调试的情况下.

![](https://ws1.sinaimg.cn/large/6b297ce5gy1fxx5dkqjlej21gb01l3yr.jpg)

​        当这个警告出现的时候就已经触发了Eureka Server的自我保护机制了.服务注册到Eureka Server之后,会维护一个心跳连接.告诉Eureka Server自己还活着.Eureka Server在运行期间,会统计心跳失败的比例在15分钟之内是否低于85%.如果低于,Eureka Server会将当前的实例注册信息保护起来,让这些实例尽量不要过期.

```
//由于本地调试很容易触发自我保护机制,建议在本地开发的时候使用来关闭保护机制.
eureka.server.enable-self-preservation=false
```







