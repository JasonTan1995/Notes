## 对象已死吗?

### 生存还是死亡?

------

要宣告一个对象死亡,至少要经过两次标记过程: 如果对象在经过可达性分析后发现没有与`GC Roots`相连接的引用链,该对象会被第一次标记并进行筛选,筛选的条件是**此对象是否有必要执行`finalize()`方法**.当对象没有覆盖`finalize()`方法,或者`finalize()`方法已经被虚拟机调用过,虚拟机将这两种情况都视为:**没有必要执行**.

#### 有必要执行`finalize()`方法

如果对象被判定为有必要执行`finalize()`方法,那么该对象将会放置到一个叫做`F-Queue`的队列之中,并在稍后由一个虚拟机自动建立,低优先级的`Finalizer`线程去执行它.这里的执行是指虚拟机会触发这个方法,但并不会承诺会等待他运行结束.

> 为什么不会承诺等待该线程运行结束?
>
> 如果一个对象在`finalize()`方法中执行缓慢,或者发生了死循环,将很可能会导致`F-Queue`队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃.

`finalize()`方法是对象逃脱死亡的最后一次机会,稍后`GC`将对`F-Queue`中的对象进行第二次小规模的标记,如果对象要在`finalize()`中成功拯救自己就需要重新与引用链上的任何一个对象建立关联即可,就像把自己赋值给某个类的变量或者对象的成员变量.那该对象就会在第二次标记时被移出集合.

**如果对象这时候还没有逃脱,那基本上它就真的被回收了.**

```java
public class FinalizeEscapeGC{
    public static FinalizeEscapeGC SAVE_HOOK = null;
    
    public void alive() {
        System.out.println("yes, I'm still alive");
    }
    
    @Override
    protected void finalize() throws Throwable{
        super.finalize();
        System.out.println("finalized methdo executed!");
        SAVE_HOOK = this;
    }
    
    public static void main(String[]args) {
         SAVE_HOOK = new FinalizeEscapeGC();
         SAVE_HOOK = null;
         System.gc();
         Thread.sleep(500);
        if (SAVE_HOOK != null) {
             SAVE_HOOK.alive();
        } else {
            System.out.println("no, i' m dead");
        }
        
        SAVE_HOOK = null;
         System.gc();
         Thread.sleep(500);
        if (SAVE_HOOK != null) {
             SAVE_HOOK.alive();
        } else {
            System.out.println("no, i' m dead");
        }
    }   
}
```

以上的例子证明了对象是如何在`finalize()`方法逃脱的,但也引出了任何一个对象的`finalize()`方法都会被系统自动调用一次,如果对象面临下一次回收.它的`finalize()`方法不会被再执行.所以第二段代码就会拯救失败.



### 回收方法区

------

方法区即`HotSpot`虚拟机中的永久代的垃圾回收主要回收两部分内容:废弃常量和无用的类.

#### 废弃常量

回收废弃常量与Java堆中的回收对象差不多,以常量池中字面量的回收为例,假如一个字符串`abc`已经进入常量池了,但是当前系统没有任何一个`String`对象引用常量池中的常量`abc`,如果这时候进行内存回收的话,常量`abc`将会被清理出常量池.

#### 无用的类

类需要同时满足以下三个条件才能算是无用的类:

- 该类所有的实例都已经被回收,也就是Java堆中不存在该类的任何实例.
- 加载该类的`Classloader`已经被回收.
- 该类对应的`java.lang.Class`对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法.

`HotSpot`虚拟机提供了`-Xnoclassgc`参数进行控制.

`-verbose:class`(`Product版`)以及`-XX:+TraceClassLoading`(`Product版`),`-XX:+TraceClassUnLoading(FastDebug版)`查看类加载和卸载信息.

注意:在大量使用反射,动态代理,`CGlib`等`ByteCode`框架以及动态生成JSP,`OSGi`这类频繁自定义`ClassLoader`的场景都需要虚拟机具备类卸载的功能,以保证永久代不会溢出.



### 枚举根节点

------

由于在垃圾回收进行前,需要确定堆中对象的存活,因此就需要进行可达性分析了.

`GC Roots`的节点主要在全局性的引用(常量或类静态属性)与执行上下文(栈帧中的本地变量表)中,如果要逐个检查里面的引用,会消耗很多时间,除此之外`可达性分析`对执行时间的敏感还体现在`GC`的停顿上,**因为可达性分析工作必须确保一致性,不可以出现分析过程中对象引用关系还在不断变化的情况**.这点导致`GC`进行时必须停顿所有的Java执行线程(`Stop The World`)的其中一个重要原因.即使是在几乎不会发生停顿的CMS收集器中,枚举根节点时也是必须要停顿的.

目前主流的Java虚拟机使用的都是`准确式GC`,所以当执行系统停顿下来后,并不需要检查所有执行上下文和全局引用的位置,虚拟机会有办法直接得知哪些地方存放着对象引用.

在`HotSpot`的实现中,是使用一组称为`OopMap`的数据结构来记录哪些地方存放着对象的引用.

#### `OopMap`

在类加载完成的时候,`HotSpot`会把对象内什么偏移量上是什么类的数据计算出来,在`JIT`编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用.这样`GC`扫描时就可以直接得知这些信息了.



### 安全点

------

现在还有这么一种情况:假如`OopMap`内容变化指令非常多,如果为每一条指令都生成对应的`OopMap`,那么将会需要大量的空间,这样`GC`的空间成本变得很高.

- 哪么在`HotSpot`虚拟机中是怎么解决?

> `HotSpot`只是在特定的位置记录了这些信息.这些位置称为**安全点(`SafePoint`)**,就是说程序执行时并非在所有地方都能停下来进行`GC`,只有在到达安全点时才能暂停.

- 哪些特定的位置才应该设立安全点(`SafePoint`)?(或者哪些位置才会产生`SafePoint`)

> `SafePoint`的选定不能太少,太少会导致让`GC`等待的时间太长.也不能太多,大多会导致增大运行时的负荷.
>
> 安全点的选定:**是否具有让程序长时间执行的特征**.为标准进行选定.
>
> 长时间执行的最明显特征就是指令序列复用.例如:方法调用,循环跳转,异常跳转等.具有这些功能的指令才会产生安全点.

- 对于`SafePoint`,还需要考虑如何在`GC`发生时让所有执行线程(不包括`JNI`调用的线程)都跑到最近的安全点上再停顿下来?

  这里有两种方案可供选择:抢断式中断(`Preemptive Suspension`)和主动式中断(`Voluntary Suspension`).

- 抢断式中断(`Preemptive Suspension`)

  不需要线程执行代码主动去配合, 发生`GC`时会把所有执行线程中断,如果发现有线程中断的地方不在安全点上的话,就恢复线程让线程跑到最近的安全点上.

- 主动式中断(`Voluntary Suspension`)

  当`GC`需要中断线程时,不直接对线程操作.而是设置一个标志,该标志的地方与安全点重合,另外再加上创建对象需要分配内存的地方,然后各个线程执行时主动去轮询这个标志,发现中断标志为真时就自己中断挂起.

  ```c++
  //test 指令是HotSpot生成的轮询指令.当需要暂停线程时
  //虚拟机把内存页设置为不可读,线程执行到test指令时就会产生一个自陷异常信号
  //在预先注册的异常处理器中暂停线程实现等待.这样一条汇编指令就能完成安全点轮询和触发线程中断了
  
  0x01b6d62d test  %eax,0x160100    ; {poll}
  ```

### 安全区域

------

`SafePoint`能完美保证,线程执行时在不太长的时间就能进入`GC`的`SafePoint`.但是如果遇到线程处于`Sleep`状态或者`Blocked`状态,这时线程就无法响应JVM的中断请求,走到最近的安全点中断挂起.针对这种情况就需要安全区域(`Safe Region`)来解决了.

什么是安全区域?

> 安全区域是指在一片代码中,引用关系不会发生变化.在这个区域中的任意地方开始`GC`都是安全的.

 线程如果执行到`SafeRegion`区域中的话,会通过一个状态来标识自己已经进入`SafeRegion`区域.当JVM要发起`GC`时,就不会去管状态已经标识为`SafeRegion`状态的线程了.在线程要离开`SafeRegion`区域时,它要检查系统是否完成枚举根节点或者完成`GC`整个过程.如果完成线程就继续执行下去,否则线程要等待收到安全离开`SafeRegion`的信号为止.
