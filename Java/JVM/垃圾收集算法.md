## 垃圾收集算法

### 1. 标记-清除算法
***
最基础的垃圾收集算法.算法分为两个阶段:标记和清除两个阶段.

首先标记出所需要回收的对象,标记完成后统一回收所有被标记的对象.标记过程就是执行可达性分析.

之所以该算法是最基础算法的原因:后续的收集算法都是基于这种思路并对其不足进行改进而得到的.

标记清除算法的主要不足有两个:

1. 效率问题:标记和清除两个过程的效率都不高.
2. 空间问题:标记清除之后会产生大量不连续的内存碎片,空间碎片大多可能会导致以后在程序运行过程中需要分配大对象时,无法找到足够的连续内存而不得不触发另一次垃圾收集动作.

[![ePpWBF.md.png](https://s2.ax1x.com/2019/07/22/ePpWBF.md.png)](https://imgchr.com/i/ePpWBF)



### 2. 复制算法
***
为了解决效率问题,复制算法出现了.

它将可用内存按容量划分为大小相等的两块,每次只使用其中的一块.当其中一块内存使用完了,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉.

好处:这样使得每次都是对整个半区进行内存回收,内存分配时也就不用考虑内存碎片等复杂情况了,只要移动堆顶指针,按顺序分配内存即可,实现简单,运行高效.

坏处:以缩小内存为代价,将内存缩小为原来的一半.而且在对象存活率较高时就要进行较多的复制操作,效率将会变低.

如果不想浪费50%的空间,就需要有额外的空间进行分配担保,以应对被使用的内存中所有对象都100%存活的极端情况.

[![ePGNid.md.png](https://s2.ax1x.com/2019/07/22/ePGNid.md.png)](https://imgchr.com/i/ePGNid)

这种算法大多数用在新生代中:

- 将内存分为一块比较大的Eden空间和两块比较小的Survivor空间

- 每次使用Eden和其中一块Survivor.当回收时,将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上.

- 最后清理掉Eden和刚刚用过的Survivor空间.



### 3. 标记-整理算法
***
标记-整理(`Mark Compact`)算法,标记过程仍然与标记-清除算法一样,但后续步骤不是直接对可回收对象进行清理,而是让所有存活的对象都向一端移动,然后直接清理掉边界以外的内存.

[![ePGseS.md.png](https://s2.ax1x.com/2019/07/22/ePGseS.md.png)](https://imgchr.com/i/ePGseS)


### 参考资料

[深入理解Java虚拟机(第2版)](https://book.douban.com/subject/24722612/)

